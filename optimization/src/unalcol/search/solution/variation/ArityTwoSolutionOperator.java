package unalcol.search.solution.variation;

import unalcol.clone.Clone;
import unalcol.search.solution.Solution;
import unalcol.search.variation.ArityTwoSearchOperator;

/**
 * <p>Title:ArityTwo</p>
 * <p>Description: A binary operator </p>
 * <p>Copyright:    Copyright (c) 2010</p>
 * @author Jonatan Gomez
 * @version 1.0
 */

public interface ArityTwoSolutionOperator<T> extends ArityTwoSearchOperator<T>, SolutionOperator<T> {
  /**
   * Apply the genetic operator to the first and second individuals in the population of parents
   * This method is parent compatible
   * @param parents Collection of parents used by the genetic operator (selects just the first and second
   * individuals in the collection
   * @return A collection of individuals generated by the genetic operator
   */
  @Override
  public default T[] apply( T one, T two ){
	  return get( apply( new Solution<T>(one), new Solution<T>(two) ) );
  }

  /**
   * Apply the genetic operator to the first and second individuals in the population of parents
   * This method is parent compatible
   * @param parents Collection of parents used by the genetic operator (selects just the first and second
   * individuals in the collection
   * @return A collection of individuals generated by the genetic operator
   */
  @SuppressWarnings("unchecked")
  @Override
  public default Solution<T>[] apply( Solution<T>... parents ){
	  Solution<T>[] v = (Solution<T>[])(new Object[parents.length]);
	  int n = (v.length>>1)<<1;
      for( int i=0; i<n;i+=2){
    	  Solution<T>[] p = apply( parents[i], parents[i+1] );
    	  v[i] = p[0]; 
    	  v[i+1] = p[1];
      }
      if( n < v.length ) v[n] = (Solution<T>)Clone.create(parents[n]);
      return v;
  }

  
}
